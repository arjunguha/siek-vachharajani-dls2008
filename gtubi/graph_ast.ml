(*

Copyright Jeremy Siek and Manish Vachharajani, November 11, 2007

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*)

open Support.Pervasive
open Support.Error
open Printf
open Graph

let debug = false

type vertex_p = { inf: info; 
		  stype: ty; 
		  mutable representative: int; 
		  mutable rank: int;
		  mutable contain_vars: bool 
		}

and ty =
    ArrowT of info * int * int
  | VarT of info * string
  | DynT of info
  | IntT of info
  | BoolT of info

type expr =
  | VarE of info * string
  | IntE of info * int
  | BoolE of info * bool
  | LamE of info * string * int * expr
  | LetE of info * string * expr * expr
  | AppE of info * expr * expr

let get_expr_info e =
  match e with
     VarE (i,_) | IntE (i,_) | BoolE (i,_) | LamE (i,_,_,_) 
    | LetE (i,_,_,_) | AppE (i,_,_) ->
	i

let default_vert = {inf=UNKNOWN; stype=BoolT UNKNOWN; representative=0; contain_vars=true; rank=0}

class astgraph_edge (s:int) (t:int) = object
  val src = s
  val tgt = t
  method source = src
  method target = tgt  
end


class astgraph = object (self)

  val verts = ref (Array.make 10 default_vert)
  val num_verts = ref 0

  method add_vertex (p : vertex_p) =
    let v = !num_verts and l = Array.length !verts in
      if l < v + 1 then
	verts := Array.append !verts (Array.make l default_vert);
      !verts.(v) <- p;
      num_verts := !num_verts + 1;
      v

  method num_vertices = !num_verts

  method vertices =
    let rec loop (i:int) =
      if i = !num_verts then [] else i::loop (i+1)
    in loop 0

  method out_edges u = 
    match (!verts).(u).stype with
	ArrowT (_,v1,v2) -> 
	  [new astgraph_edge u v1; new astgraph_edge u v2]
      | _ -> []

  method edges =
    let rec loop i ls =
      if i = !num_verts then
	ls
      else
	loop (i + 1) (self#out_edges i @ ls)
    in
      loop 0 []

  method get u = !verts.(u)

end

type graph = astgraph 
type edge = astgraph_edge

let g = new astgraph


(*

  Find the representative of a set and perform path halving.

*)

let rec find v =
  let v = ref v in
  let parent = ref (g#get !v).representative in
  let grandparent = ref (g#get !parent).representative in
    while !parent != !grandparent do
      (g#get !v).representative <- !grandparent;
      v := !grandparent;
      parent := (g#get !v).representative;
      grandparent := (g#get !parent).representative
    done;
    !parent

(*

  Union by rank.

*)

let union u v order_matters =
  if order_matters then (
      if (g#get u).rank = (g#get v).rank then
	(g#get u).rank <- (g#get u).rank + 1;
      (g#get v).representative <- u;
      u)
  else if (g#get u).rank > (g#get v).rank then (
      (g#get v).representative <- u;
      u)
  else (
      (g#get u).representative <- v;
      if (g#get u).rank = (g#get v).rank then
	(g#get v).rank <- (g#get v).rank + 1;
      v
    )

let rec get_stype v =
  let v = find v in (g#get v).stype 

let rec print_node v =
  let v = find v in
    print_type v (g#get v).stype 

and print_type v t =
  match t with
      ArrowT (_, v1,v2)-> 
	sprintf "(%s -> %s)" (print_node v1) (print_node v2)
    | VarT (_,x) -> sprintf "%s_{%d}" x v
    | IntT _ -> "int"
    | DynT _ -> "?"
    | BoolT _ -> "bool"

and print_nodes vs =
  match vs with
      [v] -> print_node v
    | _ -> sprintf "{%s}" (String.concat ", "(List.map print_node vs))

let rec print_expr e =
  match e with
    | VarE (i, x) -> x
    | IntE (i,n) -> sprintf "%d" n
    | BoolE (i,n) -> sprintf "%b" n
    | LamE (i, x, t, e) -> 
	sprintf "(fun %s : %s. %s)" x (print_node t) (print_expr e)
    | LetE (i, x, e1, e2) -> 
	sprintf "(let %s = %s in %s)" x (print_expr e1) (print_expr e2)
    | AppE (i, e1, e2) ->
	sprintf "(%s %s)" (print_expr e1) (print_expr e2)

let print_edge_dot e =
  sprintf "%d -> %d" e#source e#target

let print_vertex_dot g v =
  match (g#get v).stype with
     ArrowT _ -> sprintf "%d[label=\"->(%d)\"]" v (find v) 
    | VarT (_,x) -> sprintf "%d[label=\"%s(%d)\"]" v x (find v)
    | DynT _ -> sprintf "%d[label=\"?(%d)\"]" v (find v)
    | IntT _ -> sprintf "%d[label=\"int(%d)\"]" v (find v)
    | BoolT _ -> sprintf "%d[label=\"bool(%d)\"]" v (find v)

let print_graph_dot g vs name =
  Printf.sprintf "digraph %s {\nrankdir=LR;nodesep=0.15;\nnode[fontname=\"Times-Italic\"]\nedge[fontname=\"Times-Italic\"]%s\n%s\n}\n"
    name
    (String.concat "\n" (List.map
			   (fun v -> 
			     if List.mem v vs then 
			       print_vertex_dot g v
			     else "")
			   g#vertices))
    (String.concat "\n" (List.map 
			   (fun e ->
			     if List.mem e#source vs
				 && List.mem e#target vs then
			       print_edge_dot e
			     else "")
			   g#edges))

let congruent u v =
  let edge_equal e1 e2 = find e1#target = find e2#target in
  let u = find u and v = find v in
  if u = v then true
  else if (g#get u).stype = (g#get v).stype then
    List.for_all
      (fun e1 -> List.exists (edge_equal e1) (g#out_edges v))
      (g#out_edges u)
    &&
      List.for_all
      (fun e1 -> List.exists (edge_equal e1) (g#out_edges u))
      (g#out_edges v)
  else false

let create_sharing u =
  let rec loop vs =
    match vs with
	[] -> u
      | v::vs ->
	  if (not (find u = find v)) && congruent u v then
	    union v u false
	  else
	    loop vs
  in loop g#vertices

let create_int i =
  let u = g#add_vertex {inf=i; stype=IntT i; contain_vars=false; representative=0; rank=0} in
    (g#get u).representative <- u;
    create_sharing u

let create_bool i = 
  let u = g#add_vertex {inf=i; stype=BoolT i; contain_vars=false; representative=0; rank=0} in
    (g#get u).representative <- u;
    create_sharing u

let create_arrow i t1 t2 =
  let u = g#add_vertex {inf=i; stype=ArrowT (i, t1,t2); contain_vars=true; representative=0; rank=0} in
    (g#get u).representative <- u;
    create_sharing u

let create_dyn i =
  let u = g#add_vertex {inf=i; stype=DynT i; contain_vars=false; representative=0; rank=0} in
    (g#get u).representative <- u;
    u

let create_shared_dyn i =
  let u = g#add_vertex {inf=i; stype=DynT i; contain_vars=false; representative=0; rank=0} in
    (g#get u).representative <- u;
    create_sharing u

let create_var i x =
  let u = g#add_vertex {inf=i; 
			stype=VarT (i,x); 
			contain_vars=false; representative=0; 
			rank=0} in
    (g#get u).representative <- u;
    create_sharing u

let gensym = ref 0

let gensym_var i =
  let x = Format.sprintf "_t%d" !gensym in
  incr gensym;
  create_var i x
