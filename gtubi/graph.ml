(*

Copyright Jeremy Siek and Manish Vachharajani, November 11, 2007

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*)

(*************************************************)
(* graph interfaces *)

class type ['vertex_t] edge = object
  method source : 'vertex_t
  method target : 'vertex_t
end

class type ['vertex_t, 'edge_t] graph = object
  constraint 'edge_t = 'vertex_t #edge
  method out_edges : 'vertex_t -> 'edge_t list
  method vertices : 'vertex_t list
  method num_vertices : int
end 
 
class type ['key_t,'value_t] property_map = object
  method get : 'key_t -> 'value_t
  method put : 'key_t -> 'value_t -> unit
end

type color_t = White | Gray | Black

(*************************************************)
(* depth_first_search *)

class type ['graph_t, 'vertex_t, 'edge_t] dfs_visitor = 
object
  method initialize_vertex : 'vertex_t -> 'graph_t -> unit
  method start_vertex : 'vertex_t -> 'graph_t -> unit
  method discover_vertex : 'vertex_t -> 'graph_t -> unit
  method examine_edge : 'edge_t -> 'graph_t -> unit
  method tree_edge : 'edge_t -> 'graph_t -> unit
  method back_edge : 'edge_t -> 'graph_t -> unit
  method forward_or_cross_edge : 'edge_t -> 'graph_t -> unit
  method finish_vertex : 'vertex_t -> 'graph_t -> unit
end

let rec dfs_visit
    (graph : (('vertex_t,'edge_t) # graph) as 'graph_t)
    (u : 'vertex_t)
    (vis : ('graph_t,'vertex_t,'edge_t) #dfs_visitor)
    (mark : ('vertex_t, color_t) #property_map)
    (pred : 'edge_t -> bool)
    =
  mark#put u Gray;
  vis#discover_vertex u graph;
  List.iter
    (fun e -> 
       if pred e then
	 let v = e#target in
	 let c = mark#get v in
	   vis#examine_edge e graph;
	   if c = White then
	     begin
	       vis#tree_edge e graph;
	       dfs_visit graph v vis mark pred
	     end
	   else if c = Gray then
	     vis#back_edge e graph
	   else
	     vis#forward_or_cross_edge e graph)
    (graph#out_edges u);
  mark#put u Black;
  vis#finish_vertex u graph
    
let depth_first_search
    (graph : (('vertex_t,'edge_t) # graph) as 'graph_t)
    (vis : ('graph_t,'vertex_t,'edge_t) #dfs_visitor)
    (mark : ('vertex_t, color_t) #property_map)
    (pred : 'edge_t -> bool)
    =
  List.iter (fun u -> mark#put u White) (graph#vertices);
  List.iter (fun u ->
	       if mark#get u = White then
		 begin
		   vis#start_vertex u graph;
		   dfs_visit graph u vis mark pred
		 end)
    (graph#vertices)

class ['vertex,'edge,'graph] default_dfs_visitor =
object
  method initialize_vertex (v : 'vertex) (g : 'graph) = ()
  method start_vertex  (v : 'vertex) (g : 'graph) = ()
  method discover_vertex (v : 'vertex) (g : 'graph) = ()
  method examine_edge (e : 'edge) (g : 'graph) = ()
  method tree_edge (e : 'edge) (g : 'graph) = ()
  method back_edge (e : 'edge) (g : 'graph) = ()
  method forward_or_cross_edge (e : 'edge) (g : 'graph) = ()
  method finish_vertex (v : 'vertex) (g : 'graph) = ()
end



(*************************************************)
(* topological_sort *)

class ['vertex,'edge,'graph] topo_sort_visitor =
object
  inherit ['vertex,'edge,'graph] default_dfs_visitor
  val order = ref []
    
  method get_ordering = !order

  method finish_vertex (v : 'vertex) (g : 'graph) =
    order := v::!order
end

let topological_sort g marks =
  let vis = new topo_sort_visitor in
    depth_first_search g vis marks (fun x -> true);
    vis#get_ordering

(*************************************************)
(* strong_components *)

class ['vertex,'edge,'graph] tarjan_scc_visitor 
  (comp : ('vertex,int)#property_map)
  (root : ('vertex,'vertex)#property_map)
  (discover_time  : ('vertex,int)#property_map)
  =
object
  inherit ['vertex,'edge,'graph] default_dfs_visitor
  val dfs_time = ref 0
  val c = ref 0 
  val s = ref []
  val max = 10000000

  method num_components = !c

  method discover_vertex (v : 'vertex) (g : 'graph) = 
    begin
      root#put v v;
      comp#put v max;
      discover_time#put v !dfs_time;
      dfs_time := !dfs_time + 1;
      s := v::!s
    end

  method finish_vertex (v : 'vertex) (g : 'graph) = 
    let min_discover u v = 
      if discover_time#get u < discover_time#get v then u else v in
    begin
      List.iter
	(fun e ->
	   let w = e#target in
	     if comp#get w = max then
	       root#put v (min_discover (root#get v) (root#get w)))
	(g#out_edges v);
      if root#get v = v then
	begin
	  let w = ref (List.hd !s) in
	    s := List.tl !s;
	    comp#put !w !c;
	    while not (!w = v) do
	      w := List.hd !s;
	      s := List.tl !s;
	      comp#put !w !c
	    done;
	    c := !c + 1
	end
    end
end

let strong_components
    (graph : (('vertex_t,'edge_t) # graph) as 'graph_t)
    (comp : ('vertex_t, int) #property_map)
    (root : ('vertex_t, 'vertex_t) #property_map)
    (discover_time : ('vertex_t, int) #property_map)
    (mark : ('vertex_t, color_t) #property_map)
    =
  let vis = new tarjan_scc_visitor comp root discover_time in
    depth_first_search graph vis mark (fun x -> true);
    vis#num_components

(*************************************************)
(* array_map *)

class ['a]array_map count (init : 'a) = 
object
  val tbl = Array.make count init
  method table = tbl
  method get idx = Array.get tbl idx
  method put idx value = Array.set tbl idx value
end

(*************************************************)
(* adjacency_list class *)

class ['eprop]algraph_edge (s:int) (t:int) (ep:'eprop ref) = object
  val src = s
  val tgt = t
  val p = ep
  method source = src
  method target = tgt  
  method property = p
  method equals (x : 'eprop algraph_edge) = x#source = s && x#target = t
end

class ['eprop]edge_property_map (ep : 'eprop) =
object
  method get (e : 'eprop algraph_edge) = !(e#property)
  method put (e : 'eprop algraph_edge) (p:'eprop) = e#property := p
end

class ['vprop]vertex_property_map varray =
object
  method get (v : int) = 
    !(fst varray.(v))
  method put (v : int) (p:'vprop) = 
    (fst varray.(v)) := p
end

class ['vprop,'eprop] adjacency_list
  (num_vertices_ : int)
  (default_vp : 'vprop)
  (default_ep : 'eprop) = 
object
  val num_verts = ref num_vertices_
  val oute = ref (Array.init num_vertices_ (fun _ -> (ref default_vp, [])))
  val ine = ref (Array.init num_vertices_ (fun _ -> []))

  method clear = 
    num_verts := 0;
    oute := (Array.init 0 (fun _ -> (ref default_vp, [])));
    ine := (Array.init 0 (fun _ -> []))
				   
  method add_edge src tgt (ep : 'eprop) = 
    let (vpo,elo) = (!oute).(src) in
    let eli = (!ine).(tgt) in
    let epr = ref ep in
      (!oute).(src)<-(vpo, (tgt,epr)::elo);
      (!ine).(tgt)<- (src,epr)::eli

  method add_vertex (vp : 'vprop) = 
    let v = !num_verts in
      oute := Array.append !oute [|(ref vp,[])|];
      ine := Array.append !ine [| [] |];
      num_verts := !num_verts + 1;
      v

  method has_edge src tgt =
    let (vp,el) = (!oute).(src) in
      List.mem tgt (List.map fst el)

  (* keeps u, deletes v *)
  method merge_vertices u v mfun =
    let rec remove_dups ls =
      match ls with
	  [] -> []
	| x::xs ->
	    if List.mem x xs then
	      remove_dups xs
	    else
	      x::remove_dups xs in

    for i = 0 to !num_verts - 1 do
      let (vp,el) = (!oute).(i) in
      let el = List.map (fun (tgt,ep) ->
			   if tgt = v then (u,ep)
			   else (tgt,ep)) el in
	(!oute).(i) <- (vp,el)
    done;
    for i = 0 to !num_verts - 1 do
      let el = (!ine).(i) in
      let el = List.map (fun (src,ep) ->
			   if src = v then (u,ep)
			   else (src,ep)) el in
	(!ine).(i) <- el
    done;
    (let (vpu,elu) = (!oute).(u) in
     let (vpv,elv) = (!oute).(v) in
     let newp = (mfun !vpu !vpv) in
       (!oute).(u) <- (ref newp, remove_dups (elu@elv));
       (!oute).(v) <- (ref newp, []));
    let elu = (!ine).(u) in
    let elv = (!ine).(v) in
      (!ine).(u) <- remove_dups (elu@elv);
      (!ine).(v) <- []

  method remove_edge (e : 'eprop algraph_edge) =
    (let (vp,el) = (!oute).(e#source) in
     let el = List.fold_left 
       (fun rs (tgt,ep) -> 
	  if tgt = e#target && ep == (e#property) then rs
	  else (tgt,ep)::rs
       ) [] el in
       (!oute).(e#source) <- (vp,el));
    let el = (!ine).(e#target) in
    let el = List.fold_left 
      (fun rs (src,ep) -> 
	 if src = e#source && ep == (e#property) then rs
	 else (src,ep)::rs
      ) [] el in
      (!ine).(e#target) <- el
	
  method vertices =
    let rec floop (i:int) =
      if i = !num_verts then [] else i::floop (i+1)
    in floop 0
	
  method num_vertices = !num_verts
  method out_edges v = List.map (fun (n,ep) -> new algraph_edge v n ep) (snd (!oute).(v))
  method in_edges v = List.map (fun (n,ep) -> new algraph_edge n v ep) (!ine).(v)

  method adjacent_vertices v = snd (!oute).(v)

  method edges = 
    let (_,result) = Array.fold_left
	(fun (src,(sofar:('eprop algraph_edge) list)) (_,tgts) ->
	  (src+1, List.append
	     (List.map (fun (tgt,ep) -> new algraph_edge src tgt ep)
		tgts) sofar))
	(0,[]) !oute in result

  method put_vprop v p = 
    let (vpv,elv) = (!oute).(v) in
      vpv := p

  method get_vprop v = 
    let (vpv,elv) = (!oute).(v) in
      !vpv

  method set_vprop v p =
    let (vpv,elv) = (!oute).(v) in
      vpv := p

  method get_vertex_map = new vertex_property_map !oute

  method get_edge_map = new edge_property_map default_ep
end	     


let graph_to_dot
    (g : (('vertex_t,'edge_t) # graph) as 'graph_t)
    (vmap : ('vertex_t,'vprop) # property_map)
    (emap : ('edge_t,'eprop) # property_map)
    (pv : 'vprop -> string)
    (pe : 'eprop -> string)
    =
  Printf.sprintf "digraph G {\nrankdir=TB\n%s\n%s\n}\n"
    (String.concat "\n"
       (List.map
	  (fun v ->
	     Printf.sprintf "%d[label=\"(%d) %s\"];" v v (pv (vmap#get v)))
	  g#vertices))
    (String.concat "\n"
       (List.map
	  (fun e ->
	     Printf.sprintf "%d -> %d%s;" e#source e#target (pe (emap#get e)))
	  g#edges))
    

(*************************************************)
(* detect_cycles *)

exception Has_cycle

class ['vertex,'edge,'graph] cycle_detector =
object
  inherit ['vertex,'edge,'graph] default_dfs_visitor
    
  method back_edge (e : 'edge) (g : 'graph) =
    raise Has_cycle
end

let detect_cycles g p =
  let mark = new array_map (g#num_vertices) White in
  let vis = new cycle_detector in
    depth_first_search g vis mark p

(*************************************************)
(* breadth_first_search *)

(* Buffer concept *)
class type ['value_t] buffer = object
  method push : 'value_t -> unit
  method pop : 'value_t
  method empty : bool
end

(* Visitor concept *)
class type ['graph_t, 'vertex_t, 'edge_t] bfs_visitor = object
  method initialize_vertex : 'vertex_t -> 'graph_t -> unit
  method discover_vertex : 'vertex_t -> 'graph_t -> unit
  method examine_vertex : 'vertex_t -> 'graph_t -> unit
  method examine_edge : 'edge_t -> 'graph_t -> unit
  method tree_edge : 'edge_t -> 'graph_t -> unit
  method non_tree_edge : 'edge_t -> 'graph_t -> unit
  method gray_target : 'edge_t -> 'graph_t -> unit
  method black_target : 'edge_t -> 'graph_t -> unit
  method finish_vertex : 'vertex_t -> 'graph_t -> unit
end

class ['vertex,'edge,'graph] default_bfs_visitor =
object
  method initialize_vertex (v : 'vertex) (g : 'graph) = ()
  method discover_vertex (v : 'vertex) (g : 'graph) = ()
  method examine_vertex (v : 'vertex) (g : 'graph) = ()
  method examine_edge (e : 'edge) (g : 'graph) = ()
  method tree_edge (e : 'edge) (g : 'graph) = ()
  method non_tree_edge (e : 'edge) (g : 'graph) = ()
  method gray_target (e : 'edge) (g : 'graph) = ()
  method black_target (e : 'edge) (g : 'graph) = ()
  method finish_vertex (v : 'vertex) (g : 'graph) = ()
end

(* Graph Search algorithm *)
let graph_search
  (graph : (('vertex_t,'edge_t) #graph) as 'graph_t)
  (v : 'vertex_t)
  (q : 'value_t #buffer)
  (vis : ('graph_t, 'vertex_t, 'edge_t) #bfs_visitor)
  (map : ('color_t, 'key_t) #property_map) 
  (pred : 'edge_t -> bool)
    =
  map#put v Gray;
  q#push v;
  vis#discover_vertex v graph;
  while not q#empty do
    let u = q#pop in
      List.iter
	(fun e ->
	   if pred e then
	     begin
	       vis#examine_edge e graph;
	       let v = e#target in
		 if map#get v = White then
		   begin
		     vis#tree_edge e graph;
		     map#put v Gray;
		     q#push v;
		     vis#discover_vertex v graph
		   end
		 else
		   begin
		     vis#non_tree_edge e graph;
		     if map#get v = Gray then
		       vis#gray_target e graph
		     else
		       vis#black_target e graph
		   end;
	     end)
	(graph#out_edges u);
      map#put u Black;
      vis#finish_vertex u graph
  done


let breadth_first_search
  (graph : (('vertex_t,'edge_t) #graph) as 'graph_t)
  (v : 'vertex_t)
  (q : 'value_t #buffer)
  (vis : ('graph_t, 'vertex_t, 'edge_t) #bfs_visitor)
  (map : ('key_t, 'color_t) #property_map) 
  (pred : 'edge_t -> bool)
    =
  (* Set all the vertices to white*)
  List.fold_right (fun n _ ->
		     map#put n White;
		     vis#initialize_vertex n graph;
		  ())
    graph#vertices ();
  graph_search graph v q vis map pred


